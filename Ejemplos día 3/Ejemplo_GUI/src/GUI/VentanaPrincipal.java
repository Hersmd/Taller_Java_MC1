/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package GUI;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;
import javax.xml.stream.XMLInputFactory;
import javax.xml.stream.XMLStreamConstants;
import javax.xml.stream.XMLStreamException;
import javax.xml.stream.XMLStreamReader;

/**
 *
 * @author angel
 */
public class VentanaPrincipal extends javax.swing.JFrame {

    // Se crean las variables globales para poder usarlas en cualquier contexto
    // Sin que estos dependan de qué botones estemos usando
    private int[][] tablaVerdad;
    private ArrayList<String> nombresVariables;
    private int numeroVariables;
    
    /**
     * Se crea la ventana VentanaPrincipal
     * Se establece la posición de la ventana en el centro de la pantalla
     * Se establece que el usuario no puede ajustar el tamaño de la ventana
     * Se establece también el título de la ventana
     */
    public VentanaPrincipal() {
        initComponents();
        setLocationRelativeTo(null);
        setResizable(false);
        setTitle("Ejemplo Proyecto | Taller Java MC1");
    }

    /**
     * El código dentro de "Generated Code" no se debe modificar
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        botonXML = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        textAreaXML = new javax.swing.JTextArea();
        jLabel1 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        textAreaTabla = new javax.swing.JTextArea();
        botonObtenerFuncion = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        textAreaFuncion = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        botonXML.setText("Seleccionar archivo XML");
        botonXML.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonXMLActionPerformed(evt);
            }
        });

        textAreaXML.setEditable(false);
        textAreaXML.setColumns(20);
        textAreaXML.setRows(5);
        jScrollPane1.setViewportView(textAreaXML);

        jLabel1.setFont(new java.awt.Font("Segoe UI", 1, 14)); // NOI18N
        jLabel1.setText("Tabla de Verdad generada");

        textAreaTabla.setEditable(false);
        textAreaTabla.setColumns(20);
        textAreaTabla.setRows(5);
        jScrollPane2.setViewportView(textAreaTabla);

        botonObtenerFuncion.setText("Obtener función canónica");
        botonObtenerFuncion.setEnabled(false);
        botonObtenerFuncion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                botonObtenerFuncionActionPerformed(evt);
            }
        });

        textAreaFuncion.setEditable(false);
        textAreaFuncion.setColumns(20);
        textAreaFuncion.setRows(5);
        jScrollPane3.setViewportView(textAreaFuncion);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(36, 36, 36)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(botonObtenerFuncion)
                        .addContainerGap())
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 554, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 36, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 262, Short.MAX_VALUE)
                            .addComponent(botonXML, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 262, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(layout.createSequentialGroup()
                                .addGap(73, 73, 73)
                                .addComponent(jLabel1)
                                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(33, 33, 33)
                        .addComponent(botonXML))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jLabel1)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 346, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 346, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(35, 35, 35)
                .addComponent(botonObtenerFuncion)
                .addGap(18, 18, 18)
                .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(41, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void botonXMLActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonXMLActionPerformed
        // Variable para almacenar la ruta del archivo XML seleccionado
        String ruta = "";

        // Crea un componente JFileChooser para que el usuario seleccione archivos
        JFileChooser jFileChooser = new JFileChooser();

        // Configura un filtro para mostrar solo archivos con extensión .xml
        FileNameExtensionFilter filtrado = new FileNameExtensionFilter("Archivos XML", "xml");
        jFileChooser.setFileFilter(filtrado);

        // Muestra el diálogo para seleccionar archivo y guarda la respuesta del usuario
        int respuesta = jFileChooser.showOpenDialog(this);

        // Si el usuario selecciona un archivo y hace clic en "Abrir"
        if (respuesta == JFileChooser.APPROVE_OPTION) {
            // Obtiene el archivo seleccionado
            File archivo = jFileChooser.getSelectedFile();
            // Guarda la ruta absoluta del archivo
            ruta = archivo.getPath();

            // Llama al método para mostrar el contenido del XML en el JTextArea
            mostrarContenidoXML(archivo);
        }

        // Variables para almacenar los datos extraídos del XML:
        // - Número total de variables booleanas
        int numeroVariables = 0;
        // - Lista para guardar los nombres de las variables
        ArrayList<String> nombresVariables = new ArrayList<>();

        try {
            // Crea una fábrica para instanciar el lector de XML
            XMLInputFactory factory = XMLInputFactory.newInstance();
            // Crea el lector de XML usando la ruta del archivo
            XMLStreamReader reader = factory.createXMLStreamReader(new FileReader(ruta));

            // Procesa el XML evento por evento
            while (reader.hasNext()) {
                int evento = reader.next();

                // Solo nos interesan los eventos de inicio de elemento
                if (evento == XMLStreamConstants.START_ELEMENT) {
                    String tagName = reader.getLocalName();

                    // Si encuentra la etiqueta <mapa>
                    if (tagName.equals("mapa")) {
                        // Obtiene el atributo "v" que indica el número de variables
                        numeroVariables = Integer.parseInt(reader.getAttributeValue(null, "v"));

                        // Recorre todos los atributos val1, val2,... para obtener los nombres
                        for (int i = 1; i <= numeroVariables; i++) {
                            String atributo = "val" + i;
                            String nombreVariable = reader.getAttributeValue(null, atributo);
                            if (nombreVariable != null) {
                                nombresVariables.add(nombreVariable);
                            }
                        }
                    }
                }
            }
        // Manejo de excepciones posibles durante la lectura del XML
        } catch (FileNotFoundException | NumberFormatException | XMLStreamException e) {
            System.out.println("Error al leer el archivo XML: " + e.getMessage());
            return;
        }
        
        // - Lista para guardar los valores de la función booleana
        // Calcula el número total de filas (2^numeroVariables)
        int numeroFilas = (int) Math.pow(2, numeroVariables);
        // Inicializa el array con ceros manualmente
        ArrayList<Integer> valoresFuncion = new ArrayList<>();
        for (int i = 0; i < numeroFilas; i++) {
            valoresFuncion.add(0);
        }

        try {
            // Crea una fábrica para instanciar el lector de XML
            XMLInputFactory factory = XMLInputFactory.newInstance();
            // Crea el lector de XML usando la ruta del archivo
            XMLStreamReader reader = factory.createXMLStreamReader(new FileReader(ruta));

            // Procesa el XML evento por evento
            while (reader.hasNext()) {
                int evento = reader.next();

                // Solo nos interesan los eventos de inicio de elemento
                if (evento == XMLStreamConstants.START_ELEMENT) {
                    String tagName = reader.getLocalName();

                    // Si encuentra la etiqueta <valor>
                    if (tagName.equals("valor")) {
                        // Obtiene el índice del mintérmino
                        int mintermIndex = Integer.parseInt(reader.getAttributeValue(null, "min"));
                        // Obtiene el texto contenido en <valor> y lo convierte a entero
                        int valor = Integer.parseInt(reader.getElementText().trim());
                        valoresFuncion.set(mintermIndex, valor);
                    }
                }
            }
            // Cierra el lector para liberar recursos
            reader.close();
        // Manejo de excepciones posibles durante la lectura del XML
        } catch (FileNotFoundException | NumberFormatException | XMLStreamException e) {
            System.out.println("Error al leer el archivo XML: " + e.getMessage());
            return;
        }

        // Valida que los datos leídos sean consistentes:
        // - Que el número de nombres coincida con el número de variables declaradas
        // - Que el número de valores coincida con 2^numeroVariables (todas combinaciones posibles)
        if (nombresVariables.size() != numeroVariables || valoresFuncion.size() != Math.pow(2, numeroVariables)) {
            System.out.println("Error: La estructura del XML no es válida.");
            return;
        }

        // ===========================================
        // Generación de la tabla de verdad
        // ===========================================

        // Crea matriz para la tabla de verdad con columnas para variables + columna para resultado
        int[][] tablaVerdad = new int[numeroFilas][numeroVariables + 1];

        // Genera las combinaciones de 0 y 1 para las variables
        for (int columna = 0; columna < numeroVariables; columna++) {
            int contador = 0, valor = 0;
            // Calcula cada cuántas filas debe cambiar el valor (patrón binario)
            int limite = (int) Math.pow(2, numeroVariables - columna - 1);

            for (int fila = 0; fila < numeroFilas; fila++) {
                tablaVerdad[fila][columna] = valor;
                contador++;
                // Alterna entre 0 y 1 cuando alcanza el límite
                if (contador == limite) {
                    valor = 1 - valor; // Cambia 0->1 o 1->0
                    contador = 0;
                }
            }
        }

        // Asigna los valores de la función leídos del XML a la última columna
        for (int i = 0; i < numeroFilas; i++) {
            tablaVerdad[i][numeroVariables] = valoresFuncion.get(i);
        }

        // ===========================================
        // Formateo y visualización de la tabla de verdad
        // ===========================================
        String contenidoTabla = "";
        // Encabezado con nombres de variables
        contenidoTabla += "Tabla de Verdad:\n\n";
        for (String variable : nombresVariables) {
            contenidoTabla += variable + "\t";
        }
        contenidoTabla += "f1";  // Nombre de la función
        contenidoTabla += "\n";

        // Línea separadora
        for (int i = 0; i < numeroVariables; i++) {
            contenidoTabla += "----\t";
        }
        contenidoTabla += "---";
        contenidoTabla += "\n";

        // Contenido de la tabla
        for (int fila = 0; fila < numeroFilas; fila++) {
            for (int columna = 0; columna <= numeroVariables; columna++) {
                contenidoTabla += tablaVerdad[fila][columna] + "\t";
            }
            contenidoTabla += "\n";
        }
        // Muestra la tabla formateada en el JTextArea
        textAreaTabla.setText(contenidoTabla);

        // Guarda los datos en variables de clase para uso posterior
        this.numeroVariables = numeroVariables;
        this.nombresVariables = nombresVariables;
        this.tablaVerdad = tablaVerdad;
        // Habilita el botón para obtener la función booleana
        botonObtenerFuncion.setEnabled(true);
    }//GEN-LAST:event_botonXMLActionPerformed

    private void botonObtenerFuncionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_botonObtenerFuncionActionPerformed
        // Obtiene la función booleana en forma canónica
        String funcionBooleana = obtenerFuncionCanonica(tablaVerdad, nombresVariables, numeroVariables);
        // Muestra la función en el JTextArea correspondiente
        textAreaFuncion.setText("Función Booleana Canónica: " + funcionBooleana);
    }//GEN-LAST:event_botonObtenerFuncionActionPerformed

    /**
    * Método para leer y mostrar el contenido crudo de un archivo XML
    * @param archivo Archivo XML a leer
    */
    private void mostrarContenidoXML(File archivo) {
        // Usa try-with-resources para asegurar que el BufferedReader se cierre
        try (BufferedReader br = new BufferedReader(new FileReader(archivo))) {
            String contenido = "";
            String linea;
            // Lee línea por línea el archivo
            while ((linea = br.readLine()) != null) {
                // Mantiene los saltos de línea originales
                linea += "\n";
                contenido += linea;
            }
            // Muestra el contenido en el JTextArea
            textAreaXML.setText(contenido);
        } catch (IOException e) {
            // Muestra mensaje de error en un diálogo
            JOptionPane.showMessageDialog(this, "Error al leer el archivo: " + e.getMessage(), 
                                        "Error", JOptionPane.ERROR_MESSAGE);
        }
    }

    /**
     * Genera la función booleana canónica (suma de productos) a partir de la tabla de verdad
     * @param tabla Matriz con la tabla de verdad
     * @param vars Lista de nombres de variables
     * @param numVars Número de variables
     * @return String con la función booleana en forma canónica
     */
    public static String obtenerFuncionCanonica(int[][] tabla, ArrayList<String> vars, int numVars) {
        String funcion = "";
        boolean primerTermino = true;  // Controla si es el primer término para no agregar "+" al inicio
        // Recorre todas las filas de la tabla de verdad
        for (int[] tabla1 : tabla) {
            // Solo considera las filas donde la función vale 1
            if (tabla1[numVars] == 1) {
                // Agrega "+" entre términos (excepto antes del primer término)
                if (!primerTermino) {
                    funcion += " + ";
                }
                // Construye el término actual
                for (int columna = 0; columna < numVars; columna++) {
                    if (tabla1[columna] == 0) {
                        funcion += vars.get(columna) + "'";  // Variable negada
                    } else {
                        funcion += vars.get(columna);       // Variable directa
                    }
                }
                primerTermino = false;
            }
        }

        // Si no hay ningún 1 en la función, devuelve "0"
        return funcion.isEmpty() ? "0" : funcion;
    }
    
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VentanaPrincipal.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VentanaPrincipal().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton botonObtenerFuncion;
    private javax.swing.JButton botonXML;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea textAreaFuncion;
    private javax.swing.JTextArea textAreaTabla;
    private javax.swing.JTextArea textAreaXML;
    // End of variables declaration//GEN-END:variables
}
